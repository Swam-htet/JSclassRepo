<html>
<script>
    const toUpper = a => a.toUpperCase();
    const appendHi = a => a + " hi";

    // combine function for toUpper and appendHi
    // imperative style
    const combineNormal = x => toUpper(appendHi(x));

    // in functional programming style

    // using arrow function 

    // const compose = (f, g) => (x) => f(g(x));
    // const pipe = (f, g) => (x) => g(f(x));

    // const newVersion = compose(toUpper, appendHi);
    // const newVersion2 = pipe(appendHi, toUpper);
    // console.log('NewVersion ', newVersion('hello'));
    // console.log('NewVersion2 ', newVersion2('hello'));

    // simple code 
    const compose = (f, g) => {
        return (x) => {
            return f(g(x));
        }
    }
    const pipe = (f, g) => {
        return (x) => {
            return g(f(x));
        }
    }

    const newCompose = compose(toUpper, appendHi);
    const newPipe = pipe(appendHi, toUpper);


    const addOne = (x) => x + 1;
    const double = (x) => x * 2;
    const addOneAndDouble = compose(double, addOne);
    console.log('AddOneAndDouble ', addOneAndDouble(3));


    // according to the compostion rule 
    // compostion function need to match signature

    // wrong signature 
    const wrongSignature = pipe(appendHi, double);
    // run append hi first and double second 
    // add 'hi' to the input and double the output string 

    console.log("Wrong signature composition rule : " + wrongSignature(200));

</script>

</html>